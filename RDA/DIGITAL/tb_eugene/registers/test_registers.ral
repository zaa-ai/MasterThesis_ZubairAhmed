
#==================================================
# Copyright (c) $date.toString("yyyy") Elmos SE
# Author: stove
# Description : Note: This file has been generated automatically by stove
#               Note: This file should not be modified manually.
#               This file is the RAL file for generating the UVM test register model
#==================================================
 regfile TEST_TOP {

  register TMR_ANA (i_TEST_TOP.i_TEST_TOP_TMR_ANA) @'h1 {
    doc {
      Analog test register for switching internal signals to ATB.
'''Advice:''' Always write all Bits to 0 before switching to another signal.
    }

    field ENABLE_ATB (ENABLE_ATB) {
      doc {
        Enable analog test bus at AOUT
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 15;
    }
  }

  register TMR_DIG (i_TEST_TOP.i_TEST_TOP_TMR_DIG) @'h2 {
    doc {
      Analog test register for switching internal signals to ATB.
Always write all Bits to 0 before switching to another signal.
    }

    field USE_JTAG (USE_JTAG) {
      doc {
        applicative pins will switch to JTAG (inputs)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field SEL_SYNC (SEL_SYNC) {
      doc {
        Selects unsynchronized signals for output via TMR_DIG_OUT
0: output of 1^^st^^ FF
1: combinational output of input signal
      }
      bits 1;
      access rw;
      reset 0;
    }

    field IGNORE_OSC_READY (IGNORE_OSC_READY) {
      doc {
        ignores OSC_READY for gating oscillator clock
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 13;
    }
  }

  register TMR_IN (i_TEST_TOP.i_TEST_TOP_TMR_IN) @'h5 {
    doc {
      Set input signal from GPIO to certain digital signal
    }

    field tmr_in_0 (tmr_in_0) {
      doc {
        0:0
1:CSB
2:SCK
3:SDI
4:SDO
5:RFC
6:DAB
7:BFWB
8:SYNCB
9:INTB
10:CLKREF
      }
      bits 4;
      access rw;
      reset 0;
    }

    field tmr_in_1 (tmr_in_1) {
      doc {
        0:0
1:CSB
2:SCK
3:SDI
4:SDO
5:RFC
6:DAB
7:BFWB
8:SYNCB
9:INTB
10:CLKREF
      }
      bits 4;
      access rw;
      reset 0;
    }

    field tmr_in_2 (tmr_in_2) {
      doc {
        0:0
1:CSB
2:SCK
3:SDI
4:SDO
5:RFC
6:DAB
7:BFWB
8:SYNCB
9:INTB
10:CLKREF
      }
      bits 4;
      access rw;
      reset 0;
    }

    field tmr_in_3 (tmr_in_3) {
      doc {
        0:0
1:CSB
2:SCK
3:SDI
4:SDO
5:RFC
6:DAB
7:BFWB
8:SYNCB
9:INTB
10:CLKREF
      }
      bits 4;
      access rw;
      reset 0;
    }
  }

  register TMR_OUT_CSB_SCK (i_TEST_TOP.i_TEST_TOP_TMR_OUT_CSB_SCK) @'h6 {
    doc {
      select output signal at CSB or SCK
    }

    field SEL_SCK (SEL_SCK) {
      doc {
        select output signal at SCK
      }
      bits 6;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field EN_SCK (EN_SCK) {
      doc {
        enable output at SCK
      }
      bits 1;
      access rw;
      reset 0;
    }

    field SEL_CSB (SEL_CSB) {
      doc {
        select output signal at CSB
      }
      bits 6;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field EN_CSB (EN_CSB) {
      doc {
        enable output at CSB
      }
      bits 1;
      access rw;
      reset 0;
    }
  }

  register TMR_OUT_MOSI_MISO (i_TEST_TOP.i_TEST_TOP_TMR_OUT_MOSI_MISO) @'h7 {
    doc {
      select output signal at MOSI or MISO
    }

    field SEL_MISO (SEL_MISO) {
      doc {
        select output signal at MISO
      }
      bits 6;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field EN_MISO (EN_MISO) {
      doc {
        enable output at MISO
      }
      bits 1;
      access rw;
      reset 0;
    }

    field SEL_MOSI (SEL_MOSI) {
      doc {
        select output signal at MOSI
      }
      bits 6;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field EN_MOSI (EN_MOSI) {
      doc {
        enable output at MOSI
      }
      bits 1;
      access rw;
      reset 0;
    }
  }

  register TMR_OUT_BFWB_SYNCB (i_TEST_TOP.i_TEST_TOP_TMR_OUT_BFWB_SYNCB) @'h8 {
    doc {
      select output signal at BFWB or SYNCB
    }

    field SEL_SYNCB (SEL_SYNCB) {
      doc {
        select output signal at SYNCB
      }
      bits 6;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field EN_SYNCB (EN_SYNCB) {
      doc {
        enable output at SYNCB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field SEL_BFWB (SEL_BFWB) {
      doc {
        select output signal at BFWB
      }
      bits 6;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field EN_BFWB (EN_BFWB) {
      doc {
        enable output at BFWB
      }
      bits 1;
      access rw;
      reset 0;
    }
  }

  register TMR_OUT_DAB_INTB (i_TEST_TOP.i_TEST_TOP_TMR_OUT_DAB_INTB) @'h9 {
    doc {
      select output signal at DAB or INTB
    }

    field SEL_INTB (SEL_INTB) {
      doc {
        select output signal at INTB
      }
      bits 6;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field EN_INTB (EN_INTB) {
      doc {
        enable output at INTB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field SEL_DAB (SEL_DAB) {
      doc {
        select output signal at DAB
      }
      bits 6;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field EN_DAB (EN_DAB) {
      doc {
        enable output at DAB
      }
      bits 1;
      access rw;
      reset 0;
    }
  }

  register TMR_OUT_RFC (i_TEST_TOP.i_TEST_TOP_TMR_OUT_RFC) @'ha {
    doc {
      select output signal at RFC
    }

    field SEL_RFC (SEL_RFC) {
      doc {
        select output signal at RFC
      }
      bits 6;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field EN_RFC (EN_RFC) {
      doc {
        enable output at RFC
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 8;
    }
  }
}
   
regfile JTAG_standard_registers {

  register JTAG_ID (i_JTAG_standard_registers.i_JTAG_standard_registers_JTAG_ID) @'hfb {
    doc {
      ID read out
    }
    field unused {
      bits 1;
    }

    field MANUFACTURER (MANUFACTURER) {
      doc {
        'E' for Elmos
      }
      bits 11;
      access ro;
      reset 69;
    }

    field PROJECT (PROJECT) {
      doc {
        0xCBB0 = 52144
      }
      bits 16;
      access ro;
      reset 52144;
    }
    field unused {
      bits 4;
    }
  }

  register JTAG_BYPASS (i_JTAG_standard_registers.i_JTAG_standard_registers_JTAG_BYPASS) @'hff {
    doc {
      JTAG bypass
'''Note:''' data is shifted in and shifted out again
    }
    field unused {
      bits 1;
    }
  }
}
   
regfile TEST_SUPPLY {

  register TMR_ANA_SUPPLY (i_TEST_SUPPLY.i_TEST_SUPPLY_TMR_ANA_SUPPLY) @'h0 {
    doc {
      analog test register for e.g. switchting internal signals to ATB.
'''Advice:''' Always write all Bits to 0 before switching to another signal.
    }

    field IBP10U_2_ATB (IBP10U_2_ATB) {
      doc {
        10ÂµA PTAT current to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field IC5U_2_ATB (IC5U_2_ATB) {
      doc {
        trimmed 5uA reference current to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field VDDD_2_ATB (VDDD_2_ATB) {
      doc {
        VDD to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field VBG_2_ATB (VBG_2_ATB) {
      doc {
        VBG to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field VRR_2_ATB (VRR_2_ATB) {
      doc {
        ATB to VRR monitor input
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 11;
    }
  }

  register TMR_ANA_TEMP_SENSOR (i_TEST_SUPPLY.i_TEST_SUPPLY_TMR_ANA_TEMP_SENSOR) @'h4 {
    doc {
      analog test register for e.g. switchting internal signals to ATB.
'''Advice:''' Always write all Bits to 0 before switching to another signal.
    }

    field TS_2_ATB (TS_2_ATB) {
      doc {
        Connects temperature sensor voltage to AOUT
      }
      bits 1;
      access rw;
      reset 0;
    }

    field DISCONNECT_TS (DISCONNECT_TS) {
      doc {
        disconnects temperature sensor voltage from comparator
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 14;
    }
  }

  register TMR_ANA_OTP (i_TEST_SUPPLY.i_TEST_SUPPLY_TMR_ANA_OTP) @'h5 {
    doc {
      analog test register for e.g. switchting internal signals to ATB.
'''Advice:''' Always write all Bits to 0 before switching to another signal.
    }

    field OTP_VBG (OTP_VBG) {
      doc {
        VBG to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field OTP_VREF (OTP_VREF) {
      doc {
        VREF to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field OTP_VRR (OTP_VRR) {
      doc {
        VRR to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field OTP_VPP (OTP_VPP) {
      doc {
        VPP (divided by 4) to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field OTP_VPP_LOAD (OTP_VPP_LOAD) {
      doc {
        Switch on 250u load at VPP
      }
      bits 1;
      access rw;
      reset 0;
    }

    field OTP_VRR_LOAD (OTP_VRR_LOAD) {
      doc {
        Switch on load at VRR
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 10;
    }
  }

  register TMR_DIG_SUPPLY (i_TEST_SUPPLY.i_TEST_SUPPLY_TMR_DIG_SUPPLY) @'h1 {
    doc {
      digital test settings
    }

    field PREVENT_OVERTEMPERATURE_SWITCH_OFF (PREVENT_OVERTEMPERATURE_SWITCH_OFF) {
      doc {
        Disables switching of CLDO regulator and DSI transceiver at overtemperature
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 15;
    }
  }
}
   
regfile TEST_OSC {

  register TMR_ANA_TB_PLL (i_TEST_OSC.i_TEST_OSC_TMR_ANA_TB_PLL) @'h0 {
    doc {
      Analog test register for switching internal signals to ATB.
'''Advice:''' Always write all Bits to 0 before switching to another signal.
    }

    field PLL_IC5U (PLL_IC5U) {
      doc {
        PLL - IC5U to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field PLL_DOWN (PLL_DOWN) {
      doc {
        PLL - pfd down to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field PLL_UP (PLL_UP) {
      doc {
        PLL - UP signal to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field PLL_HiZ (PLL_HiZ) {
      doc {
        PLL - HiZ signal to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field PLL_PD_N (PLL_PD_N) {
      doc {
        PLL - PD_N signal to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field PLL_VCTRL (PLL_VCTRL) {
      doc {
        PLL - VCTRL to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }

    field PLL_VTUNE (PLL_VTUNE) {
      doc {
        PLL - VTUNE to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 9;
    }
  }

  register TMR_ANA_TB_OSC (i_TEST_OSC.i_TEST_OSC_TMR_ANA_TB_OSC) @'h1 {
    doc {
      Analog test register for switching internal signals to ATB.
'''Advice:''' Always write all Bits to 0 before switching to another signal.
    }

    field OSC_SFMIN (OSC_SFMIN) {
      doc {
        lowest possible frequency provided by the ring oscillator (without FLL regulation loop)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field OSC_SFMAX (OSC_SFMAX) {
      doc {
        highest possible frequency provided by the ring oscillator (without FLL regulation loop)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field OSC_PREAMP (OSC_PREAMP) {
      doc {
        Output voltage of operational amplifier driving the current to the ring oscillator
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 13;
    }
  }

  register TMR_DIG_TB (i_TEST_OSC.i_TEST_OSC_TMR_DIG_TB) @'h2 {
    doc {
      digital test settings
    }

    field CLKSW_TST_EN (CLKSW_TST_EN) {
      doc {
        CLK switch - Enable CLKSW_TST_SEL
      }
      bits 1;
      access rw;
      reset 0;
    }

    field CLKSW_TST_SEL (CLKSW_TST_SEL) {
      doc {
        CLK switch - 1: PLL used for Sysclk, 0: OSC used for sysclk
Valid with CLKSW_TST_EN = 1
      }
      bits 1;
      access rw;
      reset 0;
    }

    field CLK_AUTO_TRIM_EN (CLK_AUTO_TRIM_EN) {
      doc {
        Enable automatic trimming of internal oscillator to external reference clock at pin CLKREF
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 13;
    }
  }

  register TMR_VAL_TB (i_TEST_OSC.i_TEST_OSC_TMR_VAL_TB) @'h3 {
    doc {
      Set value of digital signal when selected via TMR_SEL
    }

    field PLL_ON (PLL_ON) {
      doc {
        Set value of PLL_ON signal
(Activates PLL block)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field PLL_HOLD (PLL_HOLD) {
      doc {
        Set value of PLL_HOLD signal
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 14;
    }
  }

  register TMR_SEL_TB (i_TEST_OSC.i_TEST_OSC_TMR_SEL_TB) @'h4 {
    doc {
      Selects digital signal for test input, value is set in Register TMR_VAL
    }

    field PLL_ON (PLL_ON) {
      doc {
        Select PLL_ON signal
(Activates PLL block)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field PLL_HOLD (PLL_HOLD) {
      doc {
        Select PLL_HOLD signal
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 14;
    }
  }
}
   
regfile TEST_DSI {

  register TMR_ANA_DSI3_TX (i_TEST_DSI.i_TEST_DSI_TMR_ANA_DSI3_TX) @'h0 {
    doc {
      Analog test register for switching internal signals to ATB.
'''Advice:''' Always write all Bits to 0 before switching to another signal.
    }

    field VNC2_CH1_2 (VNC2_CH1_2) {
      doc {
        
      }
      bits 1;
      access rw;
      reset 0;
    }

    field VNC0_CH1_2 (VNC0_CH1_2) {
      doc {
        
      }
      bits 1;
      access rw;
      reset 0;
    }

    field VNG0_CH1_2 (VNG0_CH1_2) {
      doc {
        
      }
      bits 1;
      access rw;
      reset 0;
    }

    field INN_CH1_2 (INN_CH1_2) {
      doc {
        
      }
      bits 1;
      access rw;
      reset 0;
    }

    field INP_CH1_2 (INP_CH1_2) {
      doc {
        
      }
      bits 1;
      access rw;
      reset 0;
    }

    field VBN5V_DIV_CH1_2 (VBN5V_DIV_CH1_2) {
      doc {
        
      }
      bits 1;
      access rw;
      reset 0;
    }

    field IDAC_TX_CH1_2 (IDAC_TX_CH1_2) {
      doc {
        
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 9;
    }
  }

  register TMR_ANA_DSI3_RX (i_TEST_DSI.i_TEST_DSI_TMR_ANA_DSI3_RX) @'h1 {
    doc {
      Analog test register for switching internal signals to ATB.
'''Advice:''' Always write all Bits to 0 before switching to another signal.
    }

    field I_Q_2_ATB (I_Q_2_ATB) {
      doc {
        switch quiescent current to ATB
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 15;
    }
  }

  register TMR_DIG_DSI3 (i_TEST_DSI.i_TEST_DSI_TMR_DIG_DSI3) @'h2 {
    doc {
      digital test settings
    }

    field PREVENT_DEACTIVATION (PREVENT_DEACTIVATION) {
      doc {
        Disables switching off of DSI transceiver at overvoltage and undervoltage
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 15;
    }
  }

  register TMR_SEL_DSI3 (i_TEST_DSI.i_TEST_DSI_TMR_SEL_DSI3) @'h3 {
    doc {
      Selects digital signal for test input, value is set in Register TMR_DIG_VAL
    }

    field TX (TX) {
      doc {
        Select transmitter input signal before waveshaping block
      }
      bits 1;
      access rw;
      reset 0;
    }

    field RX_TXN (RX_TXN) {
      doc {
        Select signal for enabling receive mode
      }
      bits 1;
      access rw;
      reset 0;
    }

    field TX_ON (TX_ON) {
      doc {
        Select transmitter activation signal
(Activates DSI3 transmitter)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field HVCASC_ON (HVCASC_ON) {
      doc {
        Select transmitter high voltage cascode activation signal
      }
      bits 1;
      access rw;
      reset 0;
    }

    field RX_ON (RX_ON) {
      doc {
        Select receiver enable signal
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }
    field unused {
      bits 10;
    }
  }

  register TMR_VAL_DSI3 (i_TEST_DSI.i_TEST_DSI_TMR_VAL_DSI3) @'h4 {
    doc {
      Set value of digital signal when selected via TMR_DIG_SEL
    }

    field TX (TX) {
      doc {
        Set value of transmitter input signal before waveshaping
      }
      bits 1;
      access rw;
      reset 0;
    }

    field RX_TXN (RX_TXN) {
      doc {
        Set value of signal for enabling receive mode
      }
      bits 1;
      access rw;
      reset 0;
    }

    field TX_ON (TX_ON) {
      doc {
        Set value of transmitter activation signal
(Activates DSI3 transmitter)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field HVCASC_ON (HVCASC_ON) {
      doc {
        Set value of transmitter high voltage cascode activation signal
      }
      bits 1;
      access rw;
      reset 0;
    }

    field RX_ON (RX_ON) {
      doc {
        Set value of receiver enable signal
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 5;
    }
    field unused {
      bits 6;
    }
  }

  register TMR_IN_DSI3 (i_TEST_DSI.i_TEST_DSI_TMR_IN_DSI3) @'h5 {
    doc {
      Set input signal from GPIO to certain digital signal
    }

    field tmr_in_tx (tmr_in_tx) {
      doc {
        0..3
      }
      bits 3;
      access rw;
      reset 0;
    }
    field unused {
      bits 13;
    }
  }
}
   
   
regfile scan_registers {

  register SCAN (i_scan_registers.i_scan_registers_SCAN) @'h0 {
    doc {
      Enable ATPG scan test
    }

    field SCAN (SCAN) {
      doc {
        enable scan test; once written the test can only be left with TMODE=0 or power-on-reset
      }
      bits 1;
      access w1s;
      reset 0;
    }

    field VDD_RDIV_DIS (VDD_RDIV_DIS) {
      doc {
        disable resistive divider. This will set VDD to approx. 1.2V and POR threshold to the same value (without hysteresis)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field COMPRESSION (COMPRESSION) {
      doc {
        use compression for scan test
      }
      bits 1;
      access rw;
      reset 0;
    }

    field VDD_ILOAD_DIS (VDD_ILOAD_DIS) {
      doc {
        disable internal load at VDD
      }
      bits 1;
      access rw;
      reset 0;
    }

    field VDD_DIS (VDD_DIS) {
      doc {
        disable VDD regulator
      }
      bits 1;
      access rw;
      reset 0;
    }

    field DISABLE_OSC (DISABLE_OSC) {
      doc {
        disable oscillator for scan test
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 10;
    }
  }
}
   
regfile SRAM_BIST_registers {

  register SRAM_BIST_CTRL (i_SRAM_BIST_registers.i_SRAM_BIST_registers_SRAM_BIST_CTRL) @'h8 {
    doc {
      control and configuration  SRAM BIST
    }

    field EN (EN) {
      doc {
        Connect and enables the SRAM BIST
      }
      bits 1;
      access rw;
      reset 0;
    }

    field BITWISE (BITWISE) {
      doc {
        adds bitwise check to BIST run

additional BIST duration = 4 * BITS_PER_BYTE * 1024 bus clock cycles per kByte

Note: BITS_PER_BYTE depends on additional SRAM bits for parity or ECC protection.

Note: Always set/reset this flag together with the run bit.
Note: This flag increases the BIST duration.
      }
      bits 1;
      access rw;
      reset 0;
    }

    field FOUR_6N (FOUR_6N) {
      doc {
        adds 4 pattern pair RAMADeLo 6N check to BIST run

additional BIST duration = 4 * 6 * 1024 bus clock cycles per kByte

Note: Always set/reset this flag together with the run bit.
Note: This flag increases the BIST duration.
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 13;
    }
  }

  register SRAM_BIST_STAT (i_SRAM_BIST_registers.i_SRAM_BIST_registers_SRAM_BIST_STAT) @'h9 {
    doc {
      status of SRAM BIST
    }

    field STATUS (STATUS) {
      doc {
        0: INIT (idle state)
1: PASS
2: FAIL
3: BUSY (running)

Depending on the device the SRAM BIST is implemented as 22N algorithm.

March 22N BIST variant duration = 22 * 1024 bus clock cycles per kByte

Note: To minimize BIST duration, make sure the system clock oscillator has been trimmed before.
      }
      bits 2;
      access ro;
      reset 0;
    }
    field unused {
      bits 14;
    }
  }

  register SRAM_ECC_CONTROL (i_SRAM_BIST_registers.i_SRAM_BIST_registers_SRAM_ECC_CONTROL) @'h7 {
    doc {
      Changing ECC values at certain points at SRAM
    }

    field SRAM_ECC_VAL (SRAM_ECC_VAL) {
      doc {
        DMEM ECC replacement value

Note: The actually of used val bits is device specific and may be smaller than 8 bit.
      }
      bits 7;
      access rw;
      reset 0;
    }

    field SRAM_ECC_SEL (SRAM_ECC_SEL) {
      doc {
        DMEM ECC replacement select
      }
      bits 1;
      access rw;
      reset 0;
    }

    field SRAM_ECC_SWAP (SRAM_ECC_SWAP) {
      doc {
        swaps ecc with MSB for testing,
this allows access to the parity/ecc bits via system bus
      }
      bits 1;
      access rw;
      reset 0;
    }

    field ELIP_ECC (ELIP_ECC) {
      doc {
        value of ECC to be EXORed after ECC generation when reading data of SRAM
      }
      bits 6;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }
  }
}
   
regfile OTP_test_registers {

  register OTP_WRITE_PULSE_WIDTH (i_OTP_test_registers.i_OTP_test_registers_OTP_WRITE_PULSE_WIDTH) @'haf {
    doc {
      timing for OTP pulse width
    }

    field PULSE_WIDTH (PULSE_WIDTH) {
      doc {
        pulse width in clock cycles
      }
      bits 12;
      access rw;
      reset 1800;
    }
    field unused {
      bits 4;
    }
  }
}
   
regfile Test_Registers {

  register OTP_CONTROL (i_Test_Registers.i_Test_Registers_OTP_CONTROL) @'ha0 {
    doc {
      Test Access: OTP Control Register (16bit). Read only CPU access is implemented, all bits are hold in reset state if test is inactive.
    }

    field EN_AUTO (EN_AUTO) {
      doc {
        "1" - automatically control OTP inputs (default); "0" - directly control OTP
      }
      bits 1;
      access rw;
      reset 1;
    }

    field VRREN (VRREN) {
      doc {
        '''Enable VRR on charge pump'''
      }
      bits 1;
      access rw;
      reset 0;
    }

    field VPPEN (VPPEN) {
      doc {
        '''Enable VPP on charge pump'''
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field EN (EN) {
      doc {
        '''OTP direct control EN for OTP Array 32bit''' (valid if EN_AUTO=0)
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field SEL (SEL) {
      doc {
        '''OTP direct control SEL for OTP Array 32bit''' (valid if EN_AUTO=0)
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field CTRL_CLK (CTRL_CLK) {
      doc {
        '''OTP  direct control CLK input (32bit or 12bit)''' (valid if EN_AUTO=0)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field CTRL_WE (CTRL_WE) {
      doc {
        '''OTP direct control''': "0" - read; "1" - write (valid if EN_AUTO=0)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field OTP_MON (OTP_MON) {
      doc {
        '''OTP digital Monitor on TDO'''
''b00'' - off
''b01'' - OTP Ready Signal
''b10'' - OTP CLKOUT Signal (divided)
''b11'' - OTP PPCLKOUT Signal (divided)
      }
      bits 2;
      access rw;
      reset 0;
    }

    field AUTOINC (AUTOINC) {
      doc {
        '''Auto-increment address'''
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 3;
    }
  }

  register OTP_CONFIG (i_Test_Registers.i_Test_Registers_OTP_CONFIG) @'ha1 {
    doc {
      Test Access: OTP Config Register (32bit). No CPU access is implemented, all bits are hold in reset state if test is inactive.
    }

    field OTP_MPP (OTP_MPP) {
      doc {
        OTP Charge-Pump mode control, [3:0] - VPP  trimming, [7:4] - reserved
      }
      bits 8;
      access rw;
      reset 0;
    }

    field OTP_MRR (OTP_MRR) {
      doc {
        OTP Charge-Pump Read Voltage Regulator mode control, [3:0] - VRR trimming, [6:4] - VREF trimming
      }
      bits 16;
      access rw;
      reset 0;
    }

    field OTP_MR (OTP_MR) {
      doc {
        OTP Read and Test mode control pins, read mode select
      }
      bits 8;
      access rw;
      reset 0;
    }
  }

  register OTP_WRITE (i_Test_Registers.i_Test_Registers_OTP_WRITE) @'ha2 {
    doc {
      write full Array
    }
    field unused {
      bits 8;
    }

    field data (data) {
      doc {
        data to be written
      }
      bits 12;
      access rw;
      reset 0;
    }

    field address (address) {
      doc {
        address to be written to
      }
      bits 12;
      access rw;
      reset 0;
    }
  }

  register OTP_READ (i_Test_Registers.i_Test_Registers_OTP_READ) @'ha4 {
    doc {
      read full Array
    }

    field data (data) {
      doc {
        
      }
      bits 12;
      access ro;
      reset 0;
    }
    field unused {
      bits 8;
    }

    field address (address) {
      doc {
        
      }
      bits 12;
      access rw;
      reset 0;
    }
  }

  register OTP_BIST_CONTROL (i_Test_Registers.i_Test_Registers_OTP_BIST_CONTROL) @'ha6 {
    doc {
      Test Access: OTP BIST Control Register (16bit). CPU Read/Write access.
    }

    field OTP_PGM (OTP_PGM) {
      doc {
        '''Select OTP Prog Mode by JTAG_IR=0x6A / 0x6B'''
''b0'' : JTAG BIST
''b1'' : Direct JTAG. Program Timing by IDLE State Duration for each bit.
      }
      bits 1;
      access rw;
      reset 0;
    }

    field OTP_READ (OTP_READ) {
      doc {
        '''Select OTP  Read Mode by JTAG_IR=0x6C / 0x6D'''
''b0'' : JTAG BIST
''b1'' : Direct JTAG
      }
      bits 1;
      access rw;
      reset 1;
    }

    field SOAK (SOAK) {
      doc {
        '''Read SOAK Status. Write SOAK Mode'''
''b0'' : together with OTP_PROG=b1 force programming with 100us
''b1'' : together with OTP_PROG=b1 force programming with 400us
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field EN_SOAK (EN_SOAK) {
      doc {
        Enable SOAK Pulses after normal programming
      }
      bits 1;
      access rw;
      reset 0;
    }

    field STRESS (STRESS) {
      doc {
        Enable Cell Stress Programming (High VPP with dummy Data) or Cell Stress Reading
      }
      bits 1;
      access rw;
      reset 0;
    }

    field SEL_TRP (SEL_TRP) {
      doc {
        '''Select Read Time (High Phase of OTP Clk)'''
''b0'' : typical read time
''b1'' : TRP[6:0] value from Config Register (IR=0x6F)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field SEL_RD (SEL_RD) {
      doc {
        '''Select Read Mode'''
''b0'' : typical read mode
''b1'' : RD_MODE[1:0] value from Config Register (IR=0x6F)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field SEL_MPP (SEL_MPP) {
      doc {
        '''Select MPP value source'''
''b0'' : default value (T.B.D.)
''b1'' : OTP_MPP[7:0] value from Config Register (IR=0x69)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field SEL_MRR (SEL_MRR) {
      doc {
        '''Select MRR value source'''
''b0'' : default value (T.B.D.)
''b1'' : OTP_MRR[15:0] value from Config Register (IR=0x69)
      }
      bits 1;
      access rw;
      reset 0;
    }

    field SEL_MR (SEL_MR) {
      doc {
        '''Select MR value source'''
''b0'' : default value (T.B.D.)
''b1'' : OTP_MR[7:0] value from Config Register (IR=0x69)
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field MAX_SOAK (MAX_SOAK) {
      doc {
        '''Select Maximum number of soak impulses'''
''000'' : 10 impulses
''001'' : 9 impulses
...
''111'' : 3 impulses
      }
      bits 3;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }
  }

  register OTP_READ_CONFIG (i_Test_Registers.i_Test_Registers_OTP_READ_CONFIG) @'ha7 {
    doc {
      Test Access: OTP Read Config (16bit). Read only CPU access is implemented, all bits are hold in reset state if test is inactive.
    }

    field TRP (TRP) {
      doc {
        '''t__RP__ timing configuration for BIST and Testing'''

t__RP__ = value * Sysclock period
      }
      bits 7;
      access rw;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field RD_MODE (RD_MODE) {
      doc {
        '''Select Read Mode'''
''b00'' : Single-Ended
''b01'' : Differential
''b10'' : Redundant
''b11'' : Differential-Redundant
      }
      bits 2;
      access rw;
      reset 0;
    }
    field unused {
      bits 2;
    }

    field ECCERR_L (ECCERR_L) {
      doc {
        '''Status of ECC_ERROR for OTP DATA[15:0]:'''
''b00'' - data is ok
''b01'' - found 1 error, data corrected
''b11'' - found 2 or more error, data corrupted
      }
      bits 2;
      access ro;
      reset 0;
    }

    field ECCERR_H (ECCERR_H) {
      doc {
        '''Status of ECC_ERROR for OTP DATA[31:16]:'''
''b00'' - data is ok
''b01'' - found 1 error, data corrected
''b11'' - found 2 or more error, data corrupted
      }
      bits 2;
      access ro;
      reset 0;
    }
  }

  register OTP_BIST_STATUS (i_Test_Registers.i_Test_Registers_OTP_BIST_STATUS) @'ha8 {
    doc {
      Test Access: OTP BIST Status (16bit) read only register. Read only CPU access is implemented.
    }

    field PROG_BIT (PROG_BIT) {
      doc {
        Current Programmed/Soaked Bit Position (valid from 0 to 43)
      }
      bits 6;
      access ro;
      reset 0;
    }
    field unused {
      bits 1;
    }

    field DONE (DONE) {
      doc {
        '''Ready flag for selected Programming/Soaking cycle:'''
''b0'' - High Voltage operation is in progress
''b1'' - Programming/Soaking is finished, if BUSY=1 then verification is ongoing
      }
      bits 1;
      access ro;
      reset 0;
    }

    field SOAK_PULSE (SOAK_PULSE) {
      doc {
        Current number of soak pulses for programming/soaking Bit
      }
      bits 4;
      access ro;
      reset 0;
    }

    field BUSY (BUSY) {
      doc {
        '''Busy flag:'''
''b1'' - programming/soaking/verification is in progress, OTP read is blocked
''b0'' - OTP write is finished
      }
      bits 1;
      access ro;
      reset 0;
    }

    field FAIL0 (FAIL0) {
      doc {
        Error status for expected unprogrammed bit  (expected 0, read 1). Fatal error.
      }
      bits 1;
      access ro;
      reset 0;
    }

    field FAIL1 (FAIL1) {
      doc {
        Error status for expected programmed bit  (expected 1, read 0). Need soak.
      }
      bits 1;
      access ro;
      reset 0;
    }

    field SOAK (SOAK) {
      doc {
        Status of SOAK bit from BIST Control Register
      }
      bits 1;
      access ro;
      reset 0;
    }
  }
}
   
regfile ELIP_test_register {

  register IR_ELIP_RDF (i_ELIP_test_register.i_ELIP_test_register_IR_ELIP_RDF) @'hc0 {
    doc {
      ELIP read full (address + data)
'''Note:''' a dummy read has to be performed for proper read out
    }

    field DATA (DATA) {
      doc {
        data read from internal bus
      }
      bits 16;
      access ro;
      reset 0;
    }

    field ADDR (ADDR) {
      doc {
        internal address to be read
      }
      bits 16;
      access wo;
      reset 0;
    }
  }

  register IR_ELIP_RD (i_ELIP_test_register.i_ELIP_test_register_IR_ELIP_RD) @'hc1 {
    doc {
      ELIP read (again) - data output only
    }

    field DATA (DATA) {
      doc {
        Read data at output
      }
      bits 16;
      access ro;
      reset 0;
    }
  }

  register IR_ELIP_RDI (i_ELIP_test_register.i_ELIP_test_register_IR_ELIP_RDI) @'hc2 {
    doc {
      ELIP read and increment address - data output only
    }

    field DATA (DATA) {
      doc {
        Read data at output
      }
      bits 16;
      access ro;
      reset 0;
    }
  }

  register IR_ELIP_WRF (i_ELIP_test_register.i_ELIP_test_register_IR_ELIP_WRF) @'hc3 {
    doc {
      ELIP write full (address + data)
    }

    field DATA (DATA) {
      doc {
        Data for writing
      }
      bits 16;
      access wo;
      reset 0;
    }

    field ADDR (ADDR) {
      doc {
        Address for write access
      }
      bits 16;
      access wo;
      reset 0;
    }
  }

  register IR_ELIP_WR (i_ELIP_test_register.i_ELIP_test_register_IR_ELIP_WR) @'hc4 {
    doc {
      ELIP write (again) - data input only
    }

    field DATA (DATA) {
      doc {
        Data to be written
      }
      bits 16;
      access ro;
      reset 0;
    }
  }

  register IR_ELIP_WRI (i_ELIP_test_register.i_ELIP_test_register_IR_ELIP_WRI) @'hc5 {
    doc {
      ELIP write and increment address - data input only
    }
    field unused {
      bits 16;
    }
  }
}
   
regfile TEST_WS {

  register TMR_SEL_WS (i_TEST_WS.i_TEST_WS_TMR_SEL_WS) @'h0 {
    doc {
      
    }

    field DAC (DAC) {
      doc {
        overwrite DAC for waveshaping, no TX control
      }
      bits 1;
      access rw;
      reset 0;
    }
    field unused {
      bits 15;
    }
  }

  register TMR_VAL_WS (i_TEST_WS.i_TEST_WS_TMR_VAL_WS) @'h1 {
    doc {
      
    }

    field DAC (DAC) {
      doc {
        DAC for waveshap
      }
      bits 5;
      access rw;
      reset 0;
    }
    field unused {
      bits 11;
    }
  }
}
   
   

block test_top {
  bytes 4;

  regfile TEST_TOP @'h0;
  regfile JTAG_standard_registers @'h0;
}

block test_supply {
  bytes 4;

  regfile TEST_SUPPLY @'h0;
}

block test_osc {
  bytes 4;

  regfile TEST_OSC @'h0;
}

block test_dsi {
  bytes 4;

  regfile TEST_DSI @'h0;
}

block SCAN_TEST {
  bytes 4;

  regfile scan_registers @'h0;
}

block SRAM_BIST {
  bytes 4;

  regfile SRAM_BIST_registers @'h0;
}

block otp_test {
  bytes 4;

  regfile OTP_test_registers @'h0;
}

block mem {
  bytes 4;

  regfile Test_Registers @'h0;
}

block jtag_elip {
  bytes 4;

  regfile ELIP_test_register @'h0;
}

block test_ws {
  bytes 4;

  regfile TEST_WS @'h0;
}

            
system jtag_test_registers {
  bytes 4;
	
  block test_top=TEST_TOP (i_test.i_test_top) @'h0;
  block test_supply=TEST_SUP (i_main_control.i_test_supply) @'h10;
  block test_osc=TEST_OSC (i_timebase.i_test_osc) @'h20;
  block test_dsi=TEST_DSI[2] (i_dsi3.generate_dsi3_blocks[%g].i_dsi3_block.i_test_dsi) @'h30 +'h10;
  block SCAN_TEST=TEST_SCAN (i_test.i_test_control) @'hb0;
  block SRAM_BIST=TEST_SRAM (i_data_storage.i_ram_wrapper_ecc_with_bist) @'hc0;
  block otp_test=TEST_OTP_CONFIG (i_test.i_test_control) @'h0;
  block mem=TEST_OTP @'h0;
  block jtag_elip=TEST_ELIP (i_test.i_test_control.i_jtag_elip) @'h0;
  block test_ws=TEST_WS_0 (i_dsi3.i_wave_shaping.generate_wave_shape[%g].i_test_ws) @'h50;
  block test_ws=TEST_WS_1 (i_dsi3.i_wave_shaping.generate_wave_shape[%g].i_test_ws) @'h60;
}