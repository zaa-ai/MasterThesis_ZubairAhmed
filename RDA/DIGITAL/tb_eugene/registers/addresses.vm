## macros
#macro(hex $value)
#set($intValue = $tools.parseInteger($value))
$tools.format("%x", $intValue)#end
## collect list of functional/applicative instances ("func" as EDF Instance Table Category)
#set($funcInstances = $edfTool.getInstancesContainingRegisters("func"))
`ifndef _ADDRESSES_PKG
`define _ADDRESSES_PKG
/*==================================================
 *  Copyright (c) $date.toString("yyyy") Elmos SE
 *  Author: stove
 *  Description : Note: This file has been generated automatically by stove
 *                Note: This file should not be modified manually.
 *                This file contains all functional register addresses as constants and an associative array for register naming
 *==================================================*/
package addresses_pkg;
// @SuppressProblem -nowarnmiss 1 -type fully_unread_static_variable -count 100 -length 100
#foreach($instance in $funcInstances)
	#set($instanceName = $instance.name.replaceAll("\W", "_"))
	#set($regs = $edfTool.getRegisters($instance))
	#foreach ($reg in $regs)
		#if(!$reg.name.contains("["))
			#set ($address = $tools.parseInteger($reg.address) + $tools.parseInteger($instance.baseAddress))
	parameter int ADDR_$instanceName.toUpperCase()_$reg.name = 'h#hex($address); /* $reg.description */
		#end
	#end
#end

	const string addresses[int]='{
#set($lastInstance = false)	
#foreach($instance in $funcInstances)
	#set($instanceName = $instance.name.replaceAll("\W", "_"))
	#if(!$foreach.hasNext)#set($lastInstance = true)#end
	#set($regs = $edfTool.getRegisters($instance))
	#foreach ($reg in $regs)
		#set ($address = $tools.parseInteger($reg.address) + $tools.parseInteger($instance.baseAddress))
		'h#hex($address) : "$instanceName.toUpperCase()_$reg.name"#if( $foreach.hasNext || !$lastInstance ),#end	
	#end
#end
	};

endpackage : addresses_pkg

`endif
	