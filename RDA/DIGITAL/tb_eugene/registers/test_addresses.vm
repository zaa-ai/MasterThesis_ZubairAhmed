## macros
#macro(hex $value)
#set($intValue = $tools.parseInteger($value))
$tools.format("%x", $intValue)#end
## collect list of functional/applicative instances ("func" as EDF Instance Table Category)
#set($funcInstances = $edfTool.getInstancesContainingRegisters("test"))
`ifndef _TEST_ADDRESSES_PKG
`define _TEST_ADDRESSES_PKG
//==================================================
// Copyright (c) $date.toString("yyyy") Elmos SE
// Author: stove
// Description : Note: This file has been generated automatically by stove
//               Note: This file should not be modified manually.
//               This file contains all test register addresses as constants and an associative array for test register naming
//==================================================
package test_addresses_pkg;
// @SuppressProblem -nowarnmiss 1 -type fully_unread_static_variable -count 100 -length 100
#foreach($instance in $funcInstances)
	#set($instanceName = $instance.name.replaceAll("\W", "_"))
	#set($regs = $edfTool.getRegisters($instance))
	#foreach ($reg in $regs)
		#if(!$reg.name.contains("["))
			#set ($address = $tools.parseInteger($reg.address) + $tools.parseInteger($instance.baseAddress))
	const int ADDR_$instanceName.toUpperCase()_$reg.name = 'h#hex($address); /* $reg.description */
		#end
	#end
#end

	const string test_addresses[int]='{
#set($lastInstance = false)	
#foreach($instance in $funcInstances)
	#set($instanceName = $instance.name.replaceAll("\W", "_"))
	#if(!$foreach.hasNext)#set($lastInstance = true)#end
	#set($regs = $edfTool.getRegisters($instance))
	#foreach ($reg in $regs)
		#set ($address = $tools.parseInteger($reg.address) + $tools.parseInteger($instance.baseAddress))
		'h#hex($address) : "$instanceName.toUpperCase()_$reg.name"#if( $foreach.hasNext || !$lastInstance ),#end	
	#end
#end
	};

endpackage

`endif
	